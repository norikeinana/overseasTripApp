---------------------
■Observable
---------------------
Observableは型
•Observableはsubscribeすることでデータが流れ始めること
•subscribeする際にnext, error, completeに対応した処理を記述できること
•completeしたあとではデータが流れないこと
•データを流したあとキャンセル可能なこと
•キャンセルしたあとはデータが流れなくなること
・ストリーム中のイベントを配列を扱う時のようにfilterやmapする標準のcombinatorを使うことができる。
・さらにsubscribeメソッドの代わりとしてforEachメソッドがあり、これは一つの関数を受け付け、
Promiseを返すそうです。


---------------------
■Promise
---------------------
Promiseはオブジェクトは処理の延期(deferred)と非同期処理のために使われます。
Promiseはまだ完了していないが、いずれ完了する処理を表します。

●構文
new Promise(executor);
new Promise(function(resolve, reject) { ... });

●引数
executor2つの引数resolveとrejectを通してほかの関数に処理を渡すを持つ関数。
1番目の引数はプロミスが成功した場合、2番目の引数は失敗した場合です。処理が完了したとき、これらの関数を呼ぶことができます。

executor 関数はPromiseが実装されたときに即時に実行されます。
（作成されたオブジェクトが返される時ですらexecutorはPromiseコンストラクタの前に呼ばれる）。 
resolve関数やreject関数はpromiseにバインドされて、それらを呼び出され、それぞれfulfill状態もしくはreject状態になります。
executorは非同期の作業を開始して、完了したときpromiseの最終的な値を処理するためにresolveあるいは、
もしエラーが起きたらrejectが呼び出されます。

●説明
Promise インターフェースは作成時点では分からなくてもよい値へのプロキシです。プロミスを用いることで、
非同期アクションの成功や失敗に対するハンドラを関連付けることができます。
これにより、非同期メソッドは、最終的な値を返すのではなく、未来のある時点で値を持つプロミスを返すことで、
同期メソッドと同じように値を返すことができるようになります。

Promiseの状態は次のうちの1つです:
•pending: 初期状態。成功も失敗もしていません。
•fulfilled: 処理が成功して完了したことを意味します。
•rejected: 処理が失敗したことを意味します。

pendingのプロミスは、何らかの値をもってfulfilled、もしくは何らかの理由をもってrejectedとなることができます。
そのどちらとなっても、then メソッドによって関連付けられたハンドラが呼ばれます。
(対応するハンドラがアタッチされたとき、既にプロミスが成功または失敗していても、そのハンドラは呼ばれます。
よって、同期処理とそのハンドラのアタッチと競合は発生しません。)

JavaScript での Promise は、すでに起きつつある処理を表します。
そしてその処理はコールバックを連鎖的に呼べます。
JavaScript で遅延評価は、引数なしのアロー関数で実現できます：f = () => expression によって遅延評価される式が作成され、
f を呼ぶことでその式を評価できます。




---------------------
■Observerパターンとは
---------------------
「私が帰宅したら、彼女に、SMSで知らせるようにする」の例で言うと、イベントは「私が帰宅したら」、
行動は「彼女にSMSで知らせるようにする」、そしてSMS通知を受け取るのは「彼女」。
さらに、通知を受け取る人は彼女に限定する必要はなく、たくさんの人に送ることもできますよね。

これが立派な「Observerパターン」です。
 「Observerパターン」は以下の2つの要素から構成されます。
Subject（観測したい事象）：「私が帰宅すること」
Observer（観測者・観測したい事象が発生したときに通知を受け取る者）：自分

---------------------
■Promiseとは
---------------------
JavaScriptでは多くの非同期処理をします。とくに、Node.jsでは非同期をうまく制御することが開発の肝と言っても過言ではないくらい
多くの処理が非同期で行われます。かつてはDefferdやAsyncといったライブラリを使ってこれらを制御していましたが、
それをネイティブで対応できるようになったものがPromiseです。
Promiseはnewして使います。
また第一引数に関数を必ず指定をします。
関数内では成功時の処理（resolve）と失敗時の処理（reject）を実行する引数が取得できます。




 "https://webservice.recruit.co.jp/ab-road/tour/v1/?key=667e57cdd05d9105&area=DUS&order=5&count=30&format=jsonp&callback=__ng_jsonp____req2_finished"





